---
marp: true
html: true
theme: soat
title: 'Formation F‚ôØ 5.0 ‚Ä¢ Les fonctions'
footer: 'Formation F‚ôØ 5.0 ‚Ä¢ Les fonctions'
paginate: true
---

<!-- _class: title invert -->

# Formation F‚ôØ 5.0

## *Les fonctions*

### D√©cembre 2021

---

<!-- _class: speaker invert -->

# About me

## Romain DENEAU

- SOAT depuis 2009
- Senior Developer C‚ôØ F‚ôØ TypeScript
- Passionn√© de Craft
- Auteur sur le blog de SOAT

[![social-network](./themes/soat/pictos/social_twitter.png) DeneauRomain](https://twitter.com/DeneauRomain)

[![social-network](./themes/soat/pictos/social_github.png) rdeneau](https://github.com/rdeneau)

---

<!-- _class: purple agenda invert lead -->

![bg right:30% h:300](./themes/soat/pictos/SOAT_pictos_formation.png)

## Sommaire

- Signature des fonctions
- Fonctions
- Op√©rateurs
- Interop avec BCL .NET

---

<!-- _class: green chapter invert -->

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_probleme.png)

# 1.

## Signature des fonctions

---

# Probl√®mes avec `void` en C‚ôØ

`void` oblige √† faire du sp√©cifique = 2 fois + de boulot üò†

- 2 types de d√©l√©gu√©s : `Action` vs `Func<T>`
- 2 types de t√¢ches : `Task` vs `Task<T>`

Exemple :

```cs
interface ITelemetry
{
  void Run(Action action);
  T Run<T>(Func<T> func);

  Task RunAsync(Func<Task> asyncAction);
  Task<T> RunAsync<T>(Func<Task<T>> asyncFunc);
}
```

---

# De `void` √† `Void`

‚òù Le probl√®me avec `void`, c'est que ce n'est ni un type, ni une valeur.

üí° Si on avait un type "`Void`", un *Singleton* du type :

```cs
public class Void
{
    public static readonly Void Instance = new Void();

    private Void() {}
}
```

---

# De `void` √† `Void` (2)

On peut d√©finir les *helpers* suivants pour convertir vers `Void` :

```cs
public static class VoidExtensions
{
    // Action -> Func<Void>
    public static Func<Void> AsFunc(this Action action)
    {
        action();
        return Void.Instance;
    }

    // Func<Task> -> Func<Task<Void>>
    public async static Func<Task<Void>> AsAsyncFunc(this Func<Task> asyncAction)
    {
        await asyncAction();
        return Void.Instance;
    }
}
```

---

# Simplification de `ITelemetry`

On peut √©crire une impl√©mentation par d√©faut (C‚ôØ 8) pour 2 des 4 m√©thodes :

```cs
interface ITelemetry
{
    void Run(Action action) =>
        Run(action.AsFunc());

    T Run<T>(Func<T> func);

    Task RunAsync(Func<Task> asyncAction) =>
        RunAsync(asyncAction.AsAsyncFunc());

    Task<T> RunAsync<T>(Func<Task<T>> asyncFunc);
}
```

---

# `Void` s'appelle `Unit` en F‚ôØ

En F‚ôØ, pas de fonction `void` mais des fonctions avec type de retour `Unit` / `unit`.

`unit` a une seule instance (d'o√π son nom), not√©e `()`
‚Üí Utilis√©e en tant que derni√®re expression d'une fonction *"void"* :

```fs
let voidFunction arg =
    // ...
    ()
```

---

# Fonctions sans param√®tre

`unit` sert aussi √† mod√©liser des fonctions sans param√®tre :

```fs
let oneParam arg = ...
let noParam () = ... // üëà Avec
let noParam2() = ... // üëà ou sans espace
```

üí° Int√©r√™t de la notation `()` : on dirait une fonction C‚ôØ.

‚ö†Ô∏è **Attention :** on a vite fait d'oublier les `()` !

- Oubli dans la d√©claration ‚Üí simple valeur plut√¥t que fonction
- Oubli dans l'appel ‚Üí alias de la fonction sans l'ex√©cuter

---

# Fonction `ignore`

En F‚ôØ, tout est expression mais on peut ins√©rer des expressions de type `unit`, par un exemple un `printf` avant de renvoyer la valeur

Probl√®me : quand on appelle une fonction `save` pour enregistrer en base mais elle renvoie la valeur `true` ou `false` qu'on veut ignorer.

Solution : utiliser la fonction `ignore` de signature `'a -> unit`.
‚Üí Qqsoit la valeur fournie en param√®tre, elle l'ignore et renvoie `()`.

```fs
let save entity = true

let a =
    save "bonjour" // ‚ö†Ô∏è Warning FS0020: Le r√©sultat de cette expression a le type 'bool' et est implicitement ignor√©.
    save "bonjour" |> ignore // üëå
    "ok"
```

---

# Signature d'une fonction en F‚ôØ

Notation fl√©ch√©e :

- Fonction √† 0 param√®tre : `unit -> TResult`
- Fonction √† 1 param√®tre : `T -> TResult`
- Fonction √† 2 param√®tres : `T1 -> T2 -> TResult`
- Fonction √† 3 param√®tres : `T1 -> T2 -> T3 -> TResult`

‚ùì **Quiz** : Pourquoi plusieurs `->` plut√¥t que des `,` ? Cela indique quoi ?

---

# Curryfication

Syntaxe des fonctions F‚ôØ : param√®tres s√©par√©s par des espaces
‚Üí Indique que les fonctions sont curryfi√©es
‚Üí D'o√π les `->` dans la signature entre les param√®tres

```fs
let fn () = result         // unit -> TResult
let fn arg = ()            // T    -> unit
let fn arg = result        // T    -> TResult

let fn x y = (x, y)        // T1 -> T2 -> (T1 * T2)

// Equivalents, explicitement curryfi√©s :
let fn x = fun y -> (x, y) // 1. Avec une lambda
let fn x =                 // 2. Avec une sous fonction
    let fn' y = (x, y)     // N.B. `x` vient du scope
    fn'
```

---

# Curryfication - Compilation .NET

‚òù Fonction curryfi√©e compil√©e en m√©thode avec param√®tres tuplifi√©s
‚Üí Vue comme m√©thode normale quand consomm√©e en C‚ôØ

Exemple : F‚ôØ puis √©quivalent C‚ôØ *(version simplifi√©e de [SharpLab](https://sharplab.io/#v2:DYLgZgzgNAJiDUAfAtgexgV2AUwAQEFcBeAWAChdLccAXXAQxhlwA9cBPY13eD8q6tjoA3esAx4iuAEy5EAPgZNcARnJA===))* :

```fs
module A =
    let add x y = x + y
    let value = 2 |> add 1
```

```cs
public static class A
{
    public static int add(int x, int y) => x + y;
    public static int value => 3;
}
```

---

# Conception unifi√©e des fonctions

Le type `unit` et la curryfication permettent de concevoir les fonctions simplement comme :

- **Prend un seul param√®tre** de type quelconque
  - y compris `unit` pour une fonction "sans param√®tre"
  - y compris une autre fonction *(callback)*
- **Renvoie une seule valeur** de type quelconque
  - y compris `unit` pour une fonction "ne renvoyant rien"
  - y compris une autre fonction

üëâ **Signature universelle** d'une fonction en F‚ôØ : `'T -> 'U`

---

# Ordre des param√®tres

Pas le m√™me ordre entre C‚ôØ et F‚ôØ

- Dans m√©thode extension C‚ôØ, l'objet `this` est le 1er param√®tre
  - Ex : `items.Select(x => x)`
- En F‚ôØ, "l'objet" est plut√¥t le **dernier param√®tre** : style *data-last*
  - Ex : `List.map (fun x -> x) items`

Style *data-last* favorise :

- Pipeline : `items |> List.map square |> List.sum`
- Application partielle : `let sortDesc = List.sortBy (fun i -> -i)`
- Composition de fonctions appliqu√©es partiellement jusqu'au param "*data*"
  - `(List.map square) >> List.sum`

---

# Ordre des param√®tres (2)

‚ö†Ô∏è Friction avec BCL .NET car plut√¥t *data-first*

‚òù Solution : wrapper dans une fonction avec params dans ordre sympa en F‚ôØ

```fs
let startsWith (prefix: string) (value: string) =
    value.StartsWith(prefix)
```

üí° **Tips** : utiliser `Option.defaultValue` plut√¥t que `defaultArg` avec les options

- Fonctions font la m√™me chose mais params `option` et `value` sont invers√©s
- `defaultArg option value` : param `option` en 1er üòï
- `Option.defaultValue value option` : param `option` en dernier üëç

---

# Ordre des param√®tres (3)

De m√™me, pr√©f√©rer mettre **en 1er** les param√®tres les \+ statiques
= Ceux susceptibles d'√™tre pr√©d√©finis par application partielle

Ex : "d√©pendances" qui seraient inject√©es dans un objet en C‚ôØ

üëâ Application partielle = moyen de simuler l'injection de d√©pendances

---

<!-- _class: green chapter invert -->

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_alEchelle.png)

# 2.

## Les¬†¬† fonctions

---

# Binding d'une fonction

`let f x y = x + y + 1`

- Binding r√©alis√© avec mot cl√© `let`
- Associe √† la fois un nom (`f`) et les param√®tres (`x` et `y`)
- Annotation de type optionnelle pour param√®tres et/ou retour
  - `let f (x: int) (y: int) : int = ...`
  - Sinon, inf√©rence de type, avec possible g√©n√©ralisation auto
- Derni√®re expression ‚Üí valeur de retour de la fonction
- Possible d√©finition de sous-fonctions (non g√©n√©riques)

---

# Fonction g√©n√©rique

- Dans beaucoup de cas, inf√©rence marche avec g√©n√©ralisation auto
  - `let listOf x = [x]` ‚Üí `(x: 'a) -> 'a list`
- Annotation explicite de params g√©n√©riques
  - `let f (x: 'a) = ...` (pas besoin de faire `f<'a>` gr√¢ce au `'` üëç)
- Annotation explicite avec inf√©rence du type g√©n√©rique
  - `let f (list: list<_>) = ...`

---

# Fonction anonyme / (Expression) Lambda

Expression d√©finissant une fonction

Syntaxe : `fun parameter1 parameter2 etc -> expression`

‚òù **√Ä noter :**

- Mot cl√© `fun` obligatoire
- Fl√®che fine `->` (Java) ‚â† fl√®che grasse `=>` (C‚ôØ, Js)

---

# Fonctions anonymes - Quelques usages

### **1.** En argument d'une *high-order function*

- Pour √©viter de devoir d√©finir une fonction nomm√©e
- Recommand√©e pour une fonction courte, pour que cela reste lisible

```fs
[1..10] |> List.map (fun i -> i + 1) // üëà () autour de la lambda

// Versus en passant par une fonction nomm√©e
let add1 i = i + 1
[1..10] |> List.map add1
```

‚ö†Ô∏è Lambda inutile : `List.map (fun x -> f x)` ‚â° `List.map f`

---

### **2.** Dans un *let binding* avec inf√©rence

- Pour rendre explicite quand la fonction renvoie une fonction
- Sorte de curryfication manuelle
- √Ä utiliser avec parcimonie

```fs
let add x y = x + y                     // Version normale, curryfi√©e automatiquement
let add' x = fun y -> x + y             // Idem avec une sous lambda
let add'' = fun x -> (fun y -> x + y)   // Idem en totalement "lambda-is√©e"
```

---

### **3.** Dans un *let binding* annot√©

- Signature de la fonction pr√©-d√©finie sous forme d'un type
- Type "fonction" s'utilise un peu comme une `interface` C‚ôØ
  - Pour contraindre impl√©mentation √† suivre signature
  - Ex : *Domain modelling made functional* par Scott Wlaschin

```fs
type Add = int -> int -> int

let add: Add = fun x y -> x + y // üëà Signature finale avec param nomm√©s : (x: int) -> (y: int) -> int
```

---

# Fonction anonyme `function`

- Mot cl√© `function` permet aussi de d√©finir une fonction anonyme
- Syntaxe abr√©g√©e √©quivalente √† `fun x -> match x with`
- Prend 1 param√®tre qui est implicite

```fs
let ouiNon x =
  match x with
  | true  -> "Oui"
  | false -> "Non"

// R√©√©crit avec `function`
let ouiNon = function
  | true  -> "Oui"
  | false -> "Non"
```

‚òù Pas de cas d'usage sp√©cifique. Son emploi est une question de go√ªt.

---

# D√©construction de param√®tres

- Comme en JavaScript, on peut d√©construire *inline* un param√®tre
- C'est √©galement une fa√ßon d'indiquer le type du param√®tre
- Le param√®tre appara√Æt sans nom dans la signature

Exemple avec un type *Record* üìç

```fs
type Person = { Name: string; Age: int }

let name { Name = x } = x     // Person -> string
let age { Age = x } = x       // Person -> int
let age' person = person.Age  // Equivalent explicite

let bob = { Name = "Bob"; Age = 18 } // Person
let bobAge = age bob // int = 18
```

---

# D√©construction de param√®tres (2)

On parle aussi de *pattern matching*
‚Üí Mais je pr√©f√®re r√©server ce terme pour l'usage de `match x with ...`

D√©construction pas adapt√©e pour un type union avec plusieurs cas üìç
‚Üí Ex : liste F‚ôØ *(soit vide `[]`, soit valeur + sous-liste `head::tail`)*
üí° **Solution :** faire un *pattern matching* de tous les cas de l'union

```fs
let printFirstItem (x::_) = // 'a list -> unit
//                  ~~~~  Warning FS0025: Crit√®res sp√©ciaux incomplets dans cette expression.
   printfn $"first element: {x}"

let printFirstItemOk = function
    | x::_ -> printfn $"first element: {x}"
    | []   -> printfn "none"
```

---

# Param√®tre tuple

- Comme en C‚ôØ, on peut vouloir regrouper des param√®tres d'une fonction
  - Par soucis de coh√©sion, quand ces param√®tres forment un tout
  - Pour √©viter le *code smell* [long parameter list](https://refactoring.guru/smells/long-parameter-list)
- On peut les regrouper dans un tuple et m√™me le d√©construire

```fs
// V1 : trop de param√®tres
let f x y z = ...

// V2 : param√®tres regroup√©s dans un tuple
let f params =
    let (x, y, z) = params
    ...

// V3 : idem avec tuple d√©construit sur place
let f (x, y, z) = ...
```

---

# Param√®tre tuple (2)

- `f (x, y, z)` ressemble furieusement √† une m√©thode C‚ôØ !
- La signature signale le changement : `(int * int * int) -> TResult`
  - La fonction n'a effectivement plus qu'1! param√®tre plut√¥t que 3
  - Perte possibilit√© application partielle de chaque √©l√©ment du tuple

‚òù **Conclusion** :

- Resister √† la tentation d'utiliser tout le temps un tuple *(car familier - C‚ôØ)*
- R√©server cet usage quand c'est pertinent de regrouper les param√®tres
  - Sans pour autant d√©clarer un type sp√©cifique pour ce groupe

---

# Fonction r√©cursive

- Fonction qui s'appelle elle-m√™me
- Syntaxe sp√©ciale avec mot cl√© `rec` sinon erreur `FS0039: ‚Ä¶ is not defined`
- Tr√®s courant en F‚ôØ pour remplacer les boucles `for`
  - Car c'est souvent + facile √† concevoir

Exemple : trouver nb √©tapes pour atteindre 1 dans la [suite de Syracuse](https://fr.wikipedia.org/wiki/Conjecture_de_Syracuse) / Collatz

```fs
let rec steps (n: int) : int =
    if n = 1       then 0
    elif n % 2 = 0 then 1 + steps (n / 2)
    else                1 + steps (3 * n + 1)
```

---

# *Tail recursion*

- Type de r√©cursivit√© o√π l'appel r√©cursif est la derni√®re instruction
- D√©tect√© par le compilateur et optimis√© sous forme de boucle
  - Permet d'√©viter les `StackOverflow`
- Proc√©d√© classique pouvant rendre tail r√©cursif :
  - Ajouter un param "accumulateur", comme `fold`/`reduce`

```fs
let steps (number: int) : int =
    let rec loop count n = // üëà `loop` = nom idiomatique de ce type de fonction interne r√©cursive
        if n = 1       then count
        elif n % 2 = 0 then loop (count + 1) (n / 2)      // üëà Dernier appel : `loop`
        else                loop (count + 1) (3 * n + 1)  // üëà idem
    loop 0 number // üëà Lancement de la boucle avec 0 comme valeur initiale pour `count`
```

---

# Fonctions mutuellement r√©cursives

- Fonctions qui s'appellent l'une l'autre
- Doivent √™tre d√©clar√©es ensemble :
  - 1√®re fonction indiqu√©e comme r√©cursive avec `rec`
  - autres fonctions ajout√©es √† la d√©claration avec `and`

```fs
// ‚ö†Ô∏è Algo un peu alambiqu√© servant juste d'illustration

let rec Even x =        // üëà Mot cl√© `rec`
    if x = 0 then true
    else Odd (x-1)      // üëà Appel √† `Odd` d√©finie + bas
and Odd x =             // üëà Mot cl√© `and`
    if x = 0 then false
    else Even (x-1)     // üëà Appel √† `Even` d√©finie + haut
```

---

# Surcharge / *overload* de fonctions

‚ö†Ô∏è Pas possible de surcharger une fonction

üí° Noms diff√©rents :

- `List.map (mapping: 'T -> 'U) list`
- `List.mapi (mapping: (index: int) -> 'T -> 'U) list`

üí° Impl√©mentation via fonction template üëá

---

# Fonction template

Permet de cr√©er des "surcharges" sp√©cialis√©es :

```fs
type ComparisonResult = Bigger | Smaller | Equal

// Fonction template, 'private' pour la "cacher"
let private compareTwoStrings (comparison: StringComparison) string1 string2 =
    let result = System.String.Compare(string1, string2, comparison)
    if result > 0 then
        Bigger
    else if result < 0 then
        Smaller
    else
        Equal

// Application partielle du param√®tre 'comparison'
let compareCaseSensitive   = compareTwoStrings StringComparison.CurrentCulture
let compareCaseInsensitive = compareTwoStrings StringComparison.CurrentCultureIgnoreCase
```

---

# Fonction template (2)

‚òù Emplacement du param√®tre de sp√©cialisation :

- En C‚ôØ, en dernier :

```cs
String.Compare(String, String, StringComparison)
String.Compare(String, String)
```

- En F‚ôØ, en premier pour permettre application partielle :

```fs
compareTwoStrings    : StringComparison -> String -> String -> ComparisonResult
compareCaseSensitive :                     String -> String -> ComparisonResult
```

---

# Organisation des fonctions

3 fa√ßons d'organiser les fonctions = 3 endroits o√π les d√©clarer :

- *Module* : fonction d√©clar√©e dans un module üìç
- *Nested* : fonction d√©clar√©e √† l'int√©rieur d'une valeur / fonction
  - üí° Encapsuler des helpers utilis√©s juste localement
  - ‚òù Param√®tres de la fonction chapeau accessibles √† fonction *nested*
- *Method* : fonction d√©finie comme m√©thode dans un type *(next slide)*

---

# M√©thodes

- D√©finies avec mot-cl√© `member` plut√¥t que `let`
- Choix du *self-identifier* : `this`, `me`, `_`...
- Param√®tres sont au choix :
  - Tuplifi√©s : style OOP
  - Curryfi√©s : style FP

---

## M√©thodes - Exemple

```fs
type Product = { SKU: string; Price: float } with  // üëà `with` n√©cessaire pour l'indentation
    // Style avec tuplification et `this`          // Alternative : `{ SKU...}` √† la ligne
    member this.TupleTotal(qty, discount) =
        (this.Price * float qty) - discount

    // Style avec curryfication et `me`
    member me.CurriedTotal qty discount = // üëà `me` d√©signe le "this"
        (me.Price * float qty) - discount // üëà `me.Price` pour acc√©der √† la propri√©t√© `Price`
```

---

<!-- _footer: '' -->

# Fonction *vs* M√©thode

| Fonctionnalit√©                    | Fonction  | M√©thode                  |
|-----------------------------------|-----------|--------------------------|
| Nommage                           | camelCase | PascalCase               |
| Curryfication                     | ‚úÖ oui    | ‚úÖ si non tuplifi√©s       |
| Param√®tres nomm√©s                 | ‚ùå non    | ‚úÖ si tuplifi√©s           |
| Param√®tres optionnels             | ‚ùå non    | ‚úÖ si tuplifi√©s           |
| Surcharge / *overload*            | ‚ùå non    | ‚úÖ si tuplifi√©s           |
| Inf√©rence √† l'usage               | ‚úÖ oui    | ‚ùå non                    |
| En argument d'une *high-order fn* | ‚úÖ oui    | ‚ùå non, lambda n√©cessaire |
| Support du `inline`               | ‚úÖ oui    | ‚úÖ oui                    |
| R√©cursive                         | ‚úÖ si `rec` | ‚úÖ oui                  |

---

# Fonctions standards

D√©finies dans `FSharp.Core` automatiquement import√©

## Conversion

- `box`, `tryUnbox`, `unbox` : *boxing* et (tentative de) *unboxing*
- `byte`, `char`, `decimal`, `float`, `int`, `string` : conversion en `byte`, `char`, ...
- `enum<'TEnum>` : conversion en l'enum sp√©cifi√©

---

## Math

- `abs`, `sign` : valeur absolue, signe (-1 si < 0...)
- `(a)cos(h)`, `(a)sin`, `(a)tan` : (co)sinus/tangente (inverse/hyperbolique)
- `ceil`, `floor`, `round` : arrondi (inf, sup)
- `exp`, `log`, `log10` : exponentielle, logarithme...
- `pown x (n: int)` : *power* = `x` √† la puissance `n`
- `sqrt` : *square root* / racine carr√©e

---

## Autres

- `compare a b : int`: renvoie -1 si a < b, 0 si =, 1 si >
- `hash` : calcul le hash (code)
- `max`, `min` : maximum et minimum de 2 valeurs comparables
- `ignore` : pour "avaler" une valeur et obtenir `unit`
- `id` : next slide üëá

---

## Fonction `id`

D√©finition `let id x = x` ‚Ä¢ Signature : `(x: 'T) -> 'T`
‚Üí Fonction √† un seul param√®tre d'entr√©e
‚Üí Qui ne fait que renvoyer ce param√®tre

Pourquoi une telle fonction ‚ùì
‚Üí Nom `id` = abr√©viation de `identity`
‚Üí Z√©ro / √âl√©ment neutre de la composition des fonctions

| Op√©ration          | Identit√© | Exemple                        |
|--------------------|----------|--------------------------------|
| Addition `+`       | `0`      | `0 + 5` ‚â° `5 + 0` ‚â° `5`        |
| Multiplication `*` | `1`      | `1 * 5` ‚â° `5 * 1` ‚â° `5`        |
| Composition `>>`   | `id`     | `id >> fn` ‚â° `fn >> id` ‚â° `fn` |

---

## Fonction `id` - Cas d'utilisation

Avec une *high-order function* faisant 2 choses :
‚Ä¢ 1 op√©ration
‚Ä¢ 1 mapping de valeur via param `'T -> 'U`

Ex : `List.collect fn list` = flatten + mapping

Comment faire juste l'op√©ration et pas de mapping ?

- `list |> List.collect (fun x -> x)` üëé
- `list |> List.collect id` üëç
- ‚òù Meilleure alternative : `List.concat list` üíØ

---

<!-- _class: green chapter invert -->

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_software.png)

# 3.

## Les¬†¬†¬†¬†¬† op√©rateurs

---

# Op√©rateur

Est d√©fini comme une fonction

- Op√©rateur unaire : `let (~symbols) = ...`
- Op√©rateur binaire : `let (symbols) = ...`
- *Symbols* = combinaison de `% & * + - . / < = > ? @ ^ | ! $`

2 fa√ßons d'utiliser les op√©rateurs

- En tant qu'op√©rateur ‚Üí infixe `1 + 2` ou pr√©fixe `-1`
- En tant que fonction ‚Üí chars entre `()` : `(+) 1 2` ‚â° `1 + 2`

---

# Op√©rateurs standards

√âgalement d√©finis dans `FSharp.Core`

- Op√©rateurs arithm√©tiques : `+`, `-`...
- Op√©rateurs de pipeline
- Op√©rateurs de composition

---

# Op√©rateurs *Pipe*

Op√©rateurs binaires, plac√©s entre une valeur simple et une fonction

- Appliquent la valeur √† la fonction = Passe la valeur en argument
- Permettent d'√©viter la mise entre parenth√®ses / pr√©c√©dence
- ‚àÉ plusieurs *pipes*
  - *Pipe right* `|>` : le *pipe* "classique"
  - *Pipe left* `<|` a.k.a. *pipe* invers√©
  - *Pipe right 2* `||>`
  - Etc.

---

## Op√©rateur *Pipe right* `|>`

Inverse l'ordre entre fonction et valeur : `val |> fn` ‚â° `fn val`

- Ordre naturel "sujet verbe", comme appel m√©thode d'un objet (`obj.M(x)`)
- *Pipeline* : encha√Æner appels de fonctions, sans variable interm√©diaire
- Aide inf√©rence d'objet. Exemple :

```fs
let items = ["a"; "bb"; "ccc"]

let longestKo = List.maxBy (fun x -> x.Length) items  // ‚ùå Error FS0072
//                                   ~~~~~~~~

let longest = items |> List.maxBy (fun x -> x.Length) // ‚úÖ Renvoie "ccc"
```

---

## Op√©rateur *Pipe left* `<|`

`fn <| expression` ‚â° `fn (expression)`
‚Ä¢ ‚òù Usage un peu moins courant que `|>`
‚Ä¢ ‚úÖ Avantage mineur : permet d'√©viter des parenth√®ses
‚Ä¢ ‚ùå Inconv√©nient majeur : se lit de droite √† gauche
¬†¬†¬† ‚Üí Inverse du sens lecture naturel en anglais et ordre ex√©cution

```fs
printf "%i" 1+2          // üí• Erreur
printf "%i" (1+2)        // Avec parenth√®ses
printf "%i" <| 1+2       // Avec pipe invers√©
```

---

## Op√©rateur *Pipe left* `<|` (2)

### Quid d'une expression telle que `x |> fn <| y` ‚ùì

Ex√©cut√©e de gauche √† droite :
`(x |> fn) <| y` ‚â° `(fn x) <| y` ‚â° `fn x y`

- En th√©orie : permettrait d'utiliser `fn` en position infix√©e
- En pratique : difficile √† lire √† cause du double sens de lecture ‚ùó

üëâ Conseil : **√Ä √âVITER**

---

## Op√©rateur *Pipe right 2* `||>`

`(x, y) |> fn` ‚â° `fn x y`

‚Ä¢ Pour passer 2 arguments √† la fois, sous la forme d'un tuple
‚Ä¢ Usage peu fr√©quent, par exemple avec `fold` pour passer liste & seed

```fs
let items = [1..5]

// üòï On peut manquer le 0 au bout (le seed)
let sumOfEvens = items |> List.fold (fun acc x -> if x % 2 = 0 then acc + x else acc) 0

let sumOfEvens' =
    (0, items)
    ||> List.fold (fun acc x -> if x % 2 = 0 then acc + x else acc)

// üí° Remplacer lambda par fonction nomm√©e
let addIfEven acc x = if x % 2 = 0 then acc + x else acc
let sumOfEvens'' = items |> List.fold addIfEven 0
```

---

# Op√©rateur *Compose* `>>`

Op√©rateurs binaires, plac√©s **entre deux fonctions**
‚Üí Le r√©sultat de la 1√®re fonction servira d'argument √† la 2e fonction

`f >> g` ‚â° `fun x -> g (f x)` ‚â° `fun x -> x |> f |> g`

üí° Peut se lire ¬´ `f` ensuite `g` ¬ª

‚ö†Ô∏è Les types doivent correspondre : `f: 'T -> 'U` et `g: 'U -> 'V`
‚Üí On obtient une fonction de signature `'T -> 'V`

```fs
let add1 x = x + 1
let times2 x = x * 2

let add1Times2 x = times2(add1 x) // üòï Style explicite mais + charg√©
let add1Times2' = add1 >> times2  // üëç Style concis
```

---

# Op√©rateur *Compose* inverse `<<`

Sert rarement, sauf pour retrouver un ordre naturel des termes

Exemple avec op√©rateur `not` (qui remplace le `!` du C‚ôØ) :

```fs
let Even x = x % 2 = 0

// Pipeline classique
let Odd x = x |> Even |> not

// R√©√©crit avec composition inverse
let Odd = not << Even
```

---

# *Pipe* `|>` ou *Compose* `>>` ?

#### *Compose* `let h = f >> g`

- Composition de 2 fonctions `f` et `g`
- Renvoie une nouvelle fonction
- Les fonctions `f` et `g` ne sont ex√©cut√©es que lorsque `h` l'est

#### *Pipe* `let result = value |> f`

- Juste une syntaxe diff√©rente pour passer un argument
- La fonction `f` est :
  - Ex√©cut√©e si elle n'a qu'1! param ‚Üí `result` est une valeur
  - Appliqu√©e partiellement sinon ‚Üí `result` est une fonction

---

# Style *Point-free*

A.k.a *Programmation tacite*

Fonction d√©finie par composition ou application partielle ou avec `function`
‚Üí **Param√®tre implicite**, d'o√π le ¬´ sans-point ¬ª (dans l'espace)

```fs
let add1 x = x + 1                // (x: int) -> int
let times2 x = x * 2              // (x: int) -> int
let add1Times2 = add1 >> times2   // int -> int ‚Ä¢ x implicite ‚Ä¢ Par composition

let isEven x = x % 2 = 0
let evens list = List.filter isEven list // (list: int list) -> int list
let evens' = List.filter isEven // int list -> int list ‚Ä¢ Par application partielle

let greet name age = printfn $"My name is {name} and I am %d{age} years old!" // name:string -> age:int -> unit
let greet' = printfn "My name is %s and I am %d years old!" // (string -> int -> unit)
```

---

# Style *Point-free* - Pros/Cons ‚öñÔ∏è

### ‚úÖ Avantages

Style concis ‚Ä¢ Abstraction des param√®tres, op√®re au niveau fonctions

### ‚ùå Inconv√©nients

Perd le nom du param√®tre devenu implicite dans la signature
‚Üí Sans importance si la fonction reste compr√©hensible :
¬†¬†¬†¬†‚Ä¢ Nom du param non significatif (ex. `x`)
¬†¬†¬†¬†‚Ä¢ Type du param et nom de la fonction suffisent
‚Üí D√©conseill√© pour une API publique

---

# Style *Point-free* - Limite üõë

Marche mal avec fonctions g√©n√©riques :

```fs
let isNotEmptyKo = not << List.isEmpty          // üí• Error FS0030: Restriction de valeur
let isNotEmpty<'a> = not << List.isEmpty<'a>    // üëå Avec annotation
let isNotEmpty' list = not (List.isEmpty list)  // üëå Style explicite
```

üîó [https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/conventions
#partial-application-and-point-free-programming](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/conventions#partial-application-and-point-free-programming)

---

# Fonction `inline`

üí° M√™me principe que les refactos *Inline Method*, *Inline Variable*

Indique au compilateur de *"inliner"* la fonction
‚Üí Tous les appels √† cette fonction seront remplac√©s par le corps de la fonction
‚Üí Usage typique : petite fonction/op√©rateur de "sucre syntaxique"

```fs
// See https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/prim-types.fs
let inline (|>) x f = f x
let inline ignore _ = ()

let t = true |> ignore
     ~= ignore true // Apr√®s inline du pipe
     ~= ()          // Apr√®s inline de ignore
```

---

# Op√©rateurs personnalis√©s

2 possibilit√©s :

- Surcharge d'op√©rateurs
- Cr√©ation d'un nouvel op√©rateur

---

# Surcharge d'op√©rateurs

En g√©n√©ral, concerne un type sp√©cifique
‚Üí Surcharge d√©finie √† l'int√©rieur du type associ√© *(comme en C‚ôØ)*

```fs
type Vector = { X: int; Y: int } with
    // Op√©rateur unaire (cf ~ et 1! param) d'inversion d'un vecteur
    static member (~-) (v: Vector) =
        { X = -v.X
          Y = -v.Y }

    // Op√©rateur binaire d'addition de 2 vecteurs
    static member (+) (a: Vector, b: Vector) =
        { X = a.X + b.X
          Y = a.Y + b.Y }

let v1 = -{ X=1; Y=1 } // { X = -1; Y = -1 }
let v2 = { X=1; Y=1 } + { X=1; Y=3 } // { X = 2; Y = 4 }
```

---

# Cr√©ation d'un nouvel op√©rateur

- D√©finition plut√¥t dans un module ou dans un type associ√©
- Cas d'usage classique : alias fonction existante, utilis√© en infixe

```fs
// "OR" Composition of 2 functions (fa, fb) which return an optional result
let (<||>) fa fb x =
    match fa x with
    | Some v -> Some v // Return value produced by (fa x) call
    | None   -> fb x   // Return value produced by (fb x) call

// Functions: int -> string option
let tryMatchPositiveEven x = if x > 0 && x % 2 = 0 then Some $"Even {x}" else None
let tryMatchPositiveOdd x = if x > 0 && x % 2 <> 0 then Some $"Odd {x}" else None
let tryMatch = tryMatchPositiveEven <||> tryMatchPositiveOdd

tryMatch 0;; // None
tryMatch 1;; // Some "Odd 1"
tryMatch 2;; // Some "Even 2"
```

---

# Symboles autoris√©s dans un op√©rateur

**Op√©rateur unaire "tilde"**
‚Üí `~` suivi de `+`, `-`, `+.`, `-.`, `%`, `%%`, `&`, `&&`

**Op√©rateur unaire "snake"**
‚Üí Plusieurs `~`, ex : `~~~~`

**Op√©rateur unaire "bang"**
‚Üí `!` suivi combinaison de `!`, `%`, `&`, `*`, `+`, `.`, `/`, `<`, `=`, `>`, `@`, `^`, `|`, `~`, `?`
‚Üí Sauf `!=` (!=) qui est binaire

**Op√©rateur binaire**
‚Üí Toute combinaison de `!`, `%`, `&`, `*`, `+`, `.`, `/`, `<`, `=`, `>`, `@`, `^`, `|`, `~`, `?`
‚Üí qui ne correspond pas √† un op√©rateur unaire

---

# Symboles √† l'usage

Tout op√©rateur s'utilise tel quel
‚ùó Sauf op√©rateur unaire "tilde" : s'utilise sans le `~` initial

| Op√©rateur    | D√©claration         | Usage     |
|--------------|---------------------|-----------|
| Unaire tilde | `let (~&&) x = ‚Ä¶`   | `&&x`     |
| Unaire snake | `let (~~~) x = ‚Ä¶`   | `~~~x`    |
| Unaire bang  | `let (!!!) x = ‚Ä¶`   | `!!!x`    |
| Binaire      | `let (<ÀÜ>) x y = ‚Ä¶` | `x <ÀÜ> y` |

‚òù Espace obligatoire entre `(` et `*` pour distinguer d'un commentaire `(* *)`
‚Üí `let ( *+ ) x y = x * y + y` ‚úÖ

---

# Op√©rateur ou fonction ?

## Op√©rateur infixe *vs* fonction

üëç **Pour** : ordre naturel de lecture (gauche ‚Üí droite) ‚Ä¢ √©viter parenth√®ses
¬†¬†¬†¬†¬†‚Üí `1 + 2 * 3` *vs* `multiply (add 1 2) 3`

‚ö†Ô∏è **Contre** : op√©rateur folklorique (ex : `@!`) moins compr√©hensible que
¬†¬†¬†¬†¬†fonction dont le nom utilise le **langage du domaine**

## Utiliser op√©rateur en tant que fonction

üëç Application partielle : `(+) 1` ‚â° `fun x -> x + 1` ‚Ä¢ `let isPositive = (<) 0`
üí° Composition : `(~-) >> ((*) 2)` ‚â° `fun x -> -x * 2`

---

# Pipeline avec m√©thode d'instance

Exemple : appeler `ToLower()` d'une `string`

- Via lambda : `"MyString" |> (fun x -> x.ToLower())`
- Idem via fonction nomm√©e telle que :
  - `String.toLower` de la librairie [FSharpPlus](https://fsprojects.github.io/FSharpPlus//reference/fsharpplus-string.html)
  - `"MyString" |> String.toLower`
- ~~Pipeline~~ Valeur interm√©diaire : `let low = "MyString".ToLower()`

---

# M√©mo√Øsation

üí° **Id√©e :** r√©duire le temps de calcul d'une fonction

‚ùì **Comment :** mise en cache des r√©sultats
‚Üí Au prochain appel avec m√™mes arguments, renverra r√©sultat en cache

üëâ **En pratique :** fonction `memoizeN` de la librairie [FSharpPlus](https://fsprojects.github.io/FSharpPlus/reference/fsharpplus-memoization.html#memoizeN)

‚ö†Ô∏è **Attention :** Comme tout optimisation, √† utiliser quand le besoin se fait sentir et en validant (mesurant) que cela marche sans d√©sagr√©ment annexe.

‚òù Ne pas confondre avec expression `lazy` *(slide suivante)*

---

# Lazy expression

Sucre syntaxique pour cr√©er un objet .NET `Lazy<'T>` √† partir d'une expression
‚Üí Expression pas √©valu√©e imm√©diatement mais qu'√† la 1√®re demande _([Thunk](https://en.wikipedia.org/wiki/Thunk))_
‚Üí Int√©ressant pour am√©liorer performance sans trop complexifier le code

```fs
let printAndForward x = printfn $"{x}"; x

let a = lazy (printAndForward "a")

let b = printAndForward "b"
// > b

printfn $"{a.Value} et {b}"
// > a
// > a et b

printfn $"{a.Value} et c"
// > a et c
```

---

<!-- _class: green chapter invert -->

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_architecture.png)

# 4.

## Interop avec BCL

BCL = Base Class Library .NET

---

# Appel √† une m√©thode de la BCL

- Syntaxe similaire au tuple - Ex : `System.String.Compare("a","b")`
  - M√©thode **pas** curryfi√©e ‚Üí Tous les arguments doivent √™tre sp√©cifi√©s
- Mais ne marche pas avec un vrai tuple F‚ôØ

```fs
System.String.Compare("a", "b") // ‚úÖ
System.String.Compare ("a","b") // ‚úÖ

System.String.Compare "a" "b"   // ‚ùå
System.String.Compare "a","b"   // ‚ùå

let tuple = ("a","b")
System.String.Compare tuple     // ‚ùå
```

---

# Param√®tre `out` - En C‚ôØ

`out` utilis√© pour avoir plusieurs valeurs en sortie
‚Üí Ex : `Int32.TryParse`, `Dictionary<,>.TryGetValue` :

```cs
if (int.TryParse(maybeInt, out var value))
    Console.WriteLine($"It's the number {value}.");
else
    Console.WriteLine($"{maybeInt} is not a number.");
```

---

# Param√®tre `out` - En F‚ôØ

Possibilit√© de consommer la sortie sous forme de tuple üëç

```fs
  match System.Int32.TryParse maybeInt with
  | true, i  -> printf $"It's the number {value}."
  | false, _ -> printf $"{maybeInt} is not a number."
```

üí° Fonctions F‚ôØ `tryXxx` s'appuient plut√¥t sur le type `Option<T>` üìç

---

# Instancier une classe avec `new` ?

| Classe                   | Utiliser `new`             |
|--------------------------|----------------------------|
| Quelconque               | Optionnel - Non recommand√© |
| Impl√©mente `IDisposable` | Obligatoire                |

```fs
let myvar = MyClass(12)       // üëç
let myvar2 = new MyClass(234) // ‚ö†Ô∏è Marche mais pas idiomatique

// IDisposable
let f = FileStream("hello.txt", FileMode.Open)     // ‚ö†Ô∏è Compiler warning
use f = new FileStream("hello.txt", FileMode.Open) // ‚òù `use` plut√¥t que `let`
```

---

# Appel d'une m√©thode surcharg√©e

- Compilateur peut ne pas comprendre quelle surcharge est appel√©e
- Astuce : faire appel avec argument nomm√©

```fs
let createReader fileName =
    new System.IO.StreamReader(path=fileName) // üëà Param `path` ‚Üí `filename` inf√©r√© en `string`

let createReaderByStream stream =
    new System.IO.StreamReader(stream=stream) // üëà Param `stream` de type `System.IO.Stream`
```

---

<!-- _class: green chapter invert -->

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# 5.

## üçî Quiz

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# Question 1

#### Comment d√©finir la valeur de retour `v` d'une fonction `f` ?

**A.** Il suffit de nommer la valeur `result`

**B.** Faire `return v`

**C.** `v` constitue la derni√®re ligne de `f`

‚è± 10‚Äô‚Äô

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_solution.png)

# R√©ponse 1

#### Comment d√©finir la valeur de retour `v` d'une fonction `f` ?

**A.** Il suffit de nommer la valeur `result` ‚ùå

**B.** Faire `return v` ‚ùå

**C.** `v` constitue la derni√®re ligne de `f` ‚úÖ

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# Question 2

#### Comment √©crire fonction `add` prenant 2 `string`s et renvoyant un `int`

**A.** `let add a b = a + b`

**B.** `let add (a: string) (b: string) = (int a) + (int b)`

**C.** `let add (a: string) (b: string) : int = a + b`

‚è± 20‚Äô‚Äô

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_solution.png)

# R√©ponse 2

#### Comment √©crire fonction `add` prenant 2 `string`s et renvoyant un `int`

**A.** `let add a b = a + b` ‚ùå
¬†¬†¬†¬†¬†|¬† Mauvais type inf√©r√© pour `a` et `b` : `int`

**B.** `let add (a: string) (b: string) = (int a) + (int b)` ‚úÖ
¬†¬†¬†¬†¬†|¬† Il faut sp√©cifier le type de `a` et `b`.
¬†¬†¬†¬†¬†|¬† Il faut les convertir en `int`.
¬†¬†¬†¬†¬†|¬† Le type de retour `int` peut √™tre inf√©r√©.

**C.** `let add (a: string) (b: string) : int = a + b`
¬†¬†¬†¬†¬†|¬† Ici, `+` concat√®ne les `string`s.

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# Question 3

#### Que fait le code `add >> multiply` ?

**A.** Cr√©er un pipeline

**B.** D√©finir une fonction

**C.** Cr√©er une composition

‚è± 10‚Äô‚Äô

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_solution.png)

# R√©ponse 3

#### Que fait le code `add >> multiply` ?

**A.** Cr√©er un pipeline ‚ùå

**B.** D√©finir une fonction ‚ùå

**C.** Cr√©er une composition ‚úÖ

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# Question 4

#### Retrouvez le nom de ces fonctions [Core](https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/)

#### **A.** `let ? _ = ()`

#### **B.** `let ? x = x`

#### **C.** `let ? f x = f x`

#### **D.** `let ? x f = f x`

#### **E.** `let ? f g x = g (f x)`

‚è± 60‚Äô‚Äô ¬† üí° Il peut s'agir d'op√©rateurs

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_solution.png)

# R√©ponse 4

**A.** `let inline ignore _ = ()`
¬†¬†¬†¬†¬†‚Üí **Ignore** : [prim-types.fs#L459](https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/prim-types.fs#L459)

**B.** `let id x = x`
¬†¬†¬†¬†¬†‚Üí **Identity** : [prim-types.fs#L4831](https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/prim-types.fs#L4831)

**C.** `let inline (<|) func arg = func arg`
¬†¬†¬†¬†¬†‚Üí **Pipe Left** : [prim-types.fs#L3914](https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/prim-types.fs#L3914)

**D.** `let inline (|>) arg func = func arg`
¬†¬†¬†¬†¬†‚Üí **Pipe Right** : [prim-types.fs#L3908](https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/prim-types.fs#L3908)

**E.** `let inline (>>) func1 func2 x = func2 (func1 x)`
¬†¬†¬†¬†¬†‚Üí **Compose Right** : [prim-types.fs#L3920](https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/prim-types.fs#L3920)

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# Question 5. Que signifie ces signatures ?

#### Combien de param√®tres ? De quel type ? Type du retour ?

#### **A.** `int -> unit`

#### **B.** `unit -> int`

#### **C.** `string -> string -> string`

#### **D.** `('T -> bool) -> 'T list -> 'T list`

‚è± 60‚Äô‚Äô

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_solution.png)

# R√©ponse 5. Que signifie ces signatures ?

**A.** `int -> unit`
1 param√®tre `int` - pas de valeur renvoy√©e

**B.** `unit -> int`
aucun param√®tre - renvoie un `int`

**C.** `string -> string -> string`
2 param√®tres `string` - renvoie une `string`

**D.** `('T -> bool) -> 'T list -> 'T list`
2 param√®tres : un pr√©dicat et une liste - renvoie une liste
‚Üí Fonction `filter`

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# Question 6. Signature de `h` ?

```fs
let f x = x + 1
let g x y = $"%i{x} + %i{y}"
let h = f >> g
```

#### **A.** `int -> int`

#### **B.** `int -> string`

#### **C.** `int -> int -> string`

#### **D.** `int -> int -> int`

‚è± 30‚Äô‚Äô ¬† üí° `%i{a}` indique que `a` est un `int`

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_solution.png)

# R√©ponse 6. Signature de `h` ?

#### **C.** `int -> int -> string` ‚úÖ

`let f x = x + 1` ‚Üí `f: (x: int) -> int`
¬ª `1` ‚Üí `int` ‚Üí `x: int` ‚Üí `x + 1: int`

`let g x y = $"{+x} + {+y}"` ‚Üí `(x: int) -> (y: int) -> string`
¬ª `%i{x}` ‚Üí `int`
¬ª `$"..."` ‚Üí `string`

`let h = f >> g`
¬ª `h` peut s'√©crire `let h x y = g (f x) y`
¬ª M√™me `x` que `f` ‚Üí `int`, m√™me `y` que `g` ‚Üí `int`

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_idee.png)

# Annexe 6. Signature de `h` ?

```fs
let f x = x + 1
let g x y = $"%i{x} + %i{y}"
let h = f >> g
```

‚òù **Conseil :** √©viter d'utiliser `>>` avec des fonctions d'arit√©
diff√©rente *(ici 1 pour `f`, 2 pour `g`)* car ce n'est pas lisible

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_question.png)

# Question 7. Combien vaut `f 2` ?

```fs
let f = (-) 1;
f 2 // ?
```

#### **A.** `1`

#### **B.** `3`

#### **C.** `-1`

‚è± 10‚Äô‚Äô

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_solution.png)

# R√©ponse 7. Combien vaut `f 2` ?

```fs
let f = (-) 1
f 2 // ?
```

#### **C.** `-1`

Contre-intuitif : on s'attend √† ce que f d√©cr√©mente de 1.

On comprend en √©crivant `f` ainsi :
`let f x = 1 - x`

üí° La fonction qui d√©cr√©mente de 1 peut s'√©crire :
`let f = (+) -1` ou `let f x = x - 1`

---

<!-- _class: green chapter invert -->

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_diplome.png)

# 6.

## Le¬†¬†¬† R√©cap‚Äô

---

![bg-right h:300](./themes/soat/pictos/SOAT_pictos_note.png)

√áa en fait des choses juste sur les fonctions üòâ

- Signature avec notation fl√©ch√©e
- Signature universelle `T -> U` gr√¢ce √† type `Unit` et curryfication
- Fonction g√©n√©rique, fonction anonyme/lambda
- Fonction r√©cursive et *tail recursion*
- Diff√©rences entre fonctions et m√©thodes
- Fonctions et op√©rateurs standards, dont `|>`, `>>`
- Surcharger ou cr√©er op√©rateur
- Notation *point-free*
- Interop√©rabilit√© avec la BCL

---

<!-- _class: end invert lead-->

# Merci üôè
